<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini MMORPG</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Username input dialog -->
    <div id="usernameDialog" class="dialog-overlay">
        <div class="dialog-content">
            <h2>Join the Game</h2>
            <p>Enter your username to join the multiplayer world:</p>
            <input type="text" id="usernameInput" placeholder="Enter username..." maxlength="20">
            
            <div class="avatar-section">
                <h3>Avatar (Optional)</h3>
                <p class="avatar-help">Upload 3 frames for each direction (north, south, east). West will be auto-flipped from east.</p>
                <div class="avatar-upload">
                    <input type="file" id="avatarUpload" accept="image/*" multiple>
                    <label for="avatarUpload" class="upload-button">Choose Avatar Images</label>
                    <div id="avatarPreview" class="avatar-preview"></div>
                </div>
            </div>
            
            <div class="dialog-buttons">
                <button id="joinButton">Join Game</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game state
        let gameState = {
            playerId: null,
            players: {},
            avatars: {},
            worldImage: null,
            camera: { x: 0, y: 0 },
            username: null
        };
        
        // WebSocket connection
        let socket = null;
        
        // Key state tracking
        let keyState = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        
        // Movement system
        let movementInterval = null;
        const MOVEMENT_INTERVAL = 100; // Send move command every 100ms
        
        // Click-to-move system
        let targetPosition = null;
        let isMovingToTarget = false;
        
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // World map dimensions
        const WORLD_SIZE = 2048;
        
        // Set canvas size to fill the browser window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateCamera();
            render();
        }
        
        // Load the world map image
        function loadWorldMap() {
            return new Promise((resolve) => {
                const worldImage = new Image();
                worldImage.onload = function() {
                    gameState.worldImage = worldImage;
                    resolve();
                };
                worldImage.src = 'world.jpg';
            });
        }
        
        // Update camera position to center on player
        function updateCamera() {
            if (!gameState.playerId || !gameState.players[gameState.playerId]) {
                return;
            }
            
            const player = gameState.players[gameState.playerId];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Calculate camera position to center player on screen
            let cameraX = player.x - centerX;
            let cameraY = player.y - centerY;
            
            // Clamp camera to world bounds
            cameraX = Math.max(0, Math.min(cameraX, WORLD_SIZE - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_SIZE - canvas.height));
            
            gameState.camera.x = cameraX;
            gameState.camera.y = cameraY;
        }
        
        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: worldX - gameState.camera.x,
                y: worldY - gameState.camera.y
            };
        }
        
        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + gameState.camera.x,
                y: screenY + gameState.camera.y
            };
        }
        
        // Render avatar with animation frame and direction
        function renderAvatar(player) {
            if (!player.avatar || !gameState.avatars[player.avatar]) {
                // Draw a simple colored circle as fallback
                drawFallbackAvatar(player);
                return;
            }
            
            const avatar = gameState.avatars[player.avatar];
            const screenPos = worldToScreen(player.x, player.y);
            
            // Skip rendering if avatar is outside viewport
            if (screenPos.x < -50 || screenPos.x > canvas.width + 50 || 
                screenPos.y < -50 || screenPos.y > canvas.height + 50) {
                return;
            }
            
            // Get the appropriate frame based on direction and animation
            let frames = avatar.frames[player.facing];
            let shouldFlip = false;
            
            if (!frames && player.facing === 'west') {
                // West direction uses flipped east frames as per README
                frames = avatar.frames.east;
                shouldFlip = true;
            }
            
            if (!frames || frames.length === 0) {
                // Draw fallback avatar if no frames available
                drawFallbackAvatar(player);
                return;
            }
            
            // Use animationFrame (0-2) to select correct avatar frame as per README
            const frameIndex = Math.min(Math.max(player.animationFrame || 0, 0), frames.length - 1);
            const frameData = frames[frameIndex];
            
            // Create image from base64 data
            const img = new Image();
            img.onload = function() {
                // Calculate avatar size (maintain aspect ratio)
                const maxSize = 64;
                const aspectRatio = img.width / img.height;
                let width = maxSize;
                let height = maxSize / aspectRatio;
                
                if (height > maxSize) {
                    height = maxSize;
                    width = maxSize * aspectRatio;
                }
                
                // Center the avatar on the player position
                const x = screenPos.x - width / 2;
                const y = screenPos.y - height;
                
                // Save context state
                ctx.save();
                
                // Enable smooth rendering for better quality
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                // Flip horizontally for west direction as per README
                if (shouldFlip) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -x - width, y, width, height);
                } else {
                    ctx.drawImage(img, x, y, width, height);
                }
                
                // Restore context state
                ctx.restore();
                
                // Draw username label with better positioning
                drawUsernameLabel(player.username, screenPos.x, screenPos.y - height - 8);
            };
            img.onerror = function() {
                // If image fails to load, draw fallback avatar
                drawFallbackAvatar(player);
            };
            img.src = frameData;
        }
        
        // Draw fallback avatar when no avatar data is available
        function drawFallbackAvatar(player) {
            const screenPos = worldToScreen(player.x, player.y);
            
            // Skip rendering if avatar is outside viewport
            if (screenPos.x < -50 || screenPos.x > canvas.width + 50 || 
                screenPos.y < -50 || screenPos.y > canvas.height + 50) {
                return;
            }
            
            ctx.save();
            
            // Draw a simple colored circle based on player ID
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            const colorIndex = player.id ? player.id.charCodeAt(0) % colors.length : 0;
            const color = colors[colorIndex];
            
            // Draw body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y - 20, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw head
            ctx.fillStyle = '#FFDBAC';
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y - 40, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw direction indicator
            ctx.fillStyle = '#333';
            const directionOffset = {
                'north': { x: 0, y: -8 },
                'south': { x: 0, y: 8 },
                'east': { x: 8, y: 0 },
                'west': { x: -8, y: 0 }
            };
            const offset = directionOffset[player.facing] || { x: 0, y: 8 };
            ctx.beginPath();
            ctx.arc(screenPos.x + offset.x, screenPos.y - 20 + offset.y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Draw username label
            drawUsernameLabel(player.username, screenPos.x, screenPos.y - 50);
        }
        
        // Draw username label above avatar
        function drawUsernameLabel(username, x, y) {
            ctx.save();
            
            // Set font and measure text
            ctx.font = 'bold 14px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            const textMetrics = ctx.measureText(username);
            const textWidth = textMetrics.width;
            const textHeight = 16;
            const padding = 6;
            
            // Draw background rectangle
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(
                x - textWidth/2 - padding, 
                y - textHeight - padding, 
                textWidth + padding * 2, 
                textHeight + padding
            );
            
            // Draw border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                x - textWidth/2 - padding, 
                y - textHeight - padding, 
                textWidth + padding * 2, 
                textHeight + padding
            );
            
            // Draw text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(username, x, y);
            
            ctx.restore();
        }
        
        // Send movement command to server
        function sendMoveCommand(direction) {
            if (socket && socket.readyState === WebSocket.OPEN && gameState.playerId) {
                const moveMessage = {
                    action: 'move',
                    direction: direction
                };
                socket.send(JSON.stringify(moveMessage));
                console.log('Sent move command:', direction);
            }
        }
        
        // Send stop command to server
        function sendStopCommand() {
            if (socket && socket.readyState === WebSocket.OPEN && gameState.playerId) {
                const stopMessage = {
                    action: 'stop'
                };
                socket.send(JSON.stringify(stopMessage));
                console.log('Sent stop command');
            }
        }
        
        // Start continuous movement
        function startMovement() {
            if (movementInterval) {
                return; // Already moving
            }
            
            movementInterval = setInterval(() => {
                // Check which keys are currently pressed
                const activeKeys = [];
                if (keyState.up) activeKeys.push('up');
                if (keyState.down) activeKeys.push('down');
                if (keyState.left) activeKeys.push('left');
                if (keyState.right) activeKeys.push('right');
                
                if (activeKeys.length > 0) {
                    // Send move command for the first active direction
                    // (Server will handle the movement, we just need to keep sending)
                    sendMoveCommand(activeKeys[0]);
                } else {
                    // No keys pressed, stop movement
                    stopMovement();
                }
            }, MOVEMENT_INTERVAL);
        }
        
        // Stop continuous movement
        function stopMovement() {
            if (movementInterval) {
                clearInterval(movementInterval);
                movementInterval = null;
                sendStopCommand();
            }
        }
        
        // Handle click-to-move
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Convert screen coordinates to world coordinates
            const worldPos = screenToWorld(clickX, clickY);
            
            // Clamp to world bounds
            worldPos.x = Math.max(0, Math.min(worldPos.x, WORLD_SIZE));
            worldPos.y = Math.max(0, Math.min(worldPos.y, WORLD_SIZE));
            
            // Set target position
            targetPosition = worldPos;
            isMovingToTarget = true;
            
            // Send click-to-move command to server
            if (socket && socket.readyState === WebSocket.OPEN && gameState.playerId) {
                const moveMessage = {
                    action: 'move',
                    x: Math.round(worldPos.x),
                    y: Math.round(worldPos.y)
                };
                socket.send(JSON.stringify(moveMessage));
                console.log('Sent click-to-move command:', moveMessage);
            }
        }
        
        // Draw UI overlay
        function drawUI() {
            ctx.save();
            
            // Connection status
            const isConnected = socket && socket.readyState === WebSocket.OPEN;
            const statusText = isConnected ? 'Connected' : 'Disconnected';
            const statusColor = isConnected ? '#4CAF50' : '#F44336';
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(10, 10, 120, 30);
            ctx.strokeStyle = statusColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 120, 30);
            
            ctx.fillStyle = statusColor;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Status: ${statusText}`, 20, 30);
            
            // Player count
            const playerCount = Object.keys(gameState.players).length;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(10, 50, 120, 30);
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 50, 120, 30);
            
            ctx.fillStyle = '#2196F3';
            ctx.fillText(`Players: ${playerCount}`, 20, 70);
            
            // Instructions
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(10, canvas.height - 80, 200, 70);
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, canvas.height - 80, 200, 70);
            
            ctx.fillStyle = '#FF9800';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('Controls:', 20, canvas.height - 60);
            ctx.font = '10px Arial';
            ctx.fillText('Arrow Keys - Move', 20, canvas.height - 45);
            ctx.fillText('Click - Move to location', 20, canvas.height - 30);
            ctx.fillText('Hold keys for continuous movement', 20, canvas.height - 15);
            
            // Draw target indicator if moving to target
            if (targetPosition && isMovingToTarget) {
                const targetScreen = worldToScreen(targetPosition.x, targetPosition.y);
                if (targetScreen.x >= 0 && targetScreen.x <= canvas.width && 
                    targetScreen.y >= 0 && targetScreen.y <= canvas.height) {
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(targetScreen.x, targetScreen.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner circle
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(targetScreen.x, targetScreen.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }
        
        // Main render function
        function render() {
            if (!gameState.worldImage) {
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw world map with camera offset
            ctx.drawImage(
                gameState.worldImage,
                gameState.camera.x, gameState.camera.y, canvas.width, canvas.height,
                0, 0, canvas.width, canvas.height
            );
            
            // Draw all players
            Object.values(gameState.players).forEach(player => {
                renderAvatar(player);
            });
            
            // Draw UI overlay
            drawUI();
        }
        
        // WebSocket message handlers
        function handleJoinGame(data) {
            if (data.success) {
                gameState.playerId = data.playerId;
                gameState.players = data.players;
                gameState.avatars = data.avatars;
                
                console.log('Joined game successfully!', {
                    playerId: gameState.playerId,
                    playerCount: Object.keys(gameState.players).length
                });
                
                updateCamera();
                render();
            } else {
                console.error('Failed to join game:', data.error);
            }
        }
        
        function handlePlayerJoined(data) {
            gameState.players[data.player.id] = data.player;
            gameState.avatars[data.avatar.name] = data.avatar;
            render();
        }
        
        function handlePlayersMoved(data) {
            Object.assign(gameState.players, data.players);
            updateCamera();
            render();
        }
        
        function handlePlayerLeft(data) {
            delete gameState.players[data.playerId];
            render();
        }
        
        // WebSocket connection and message handling
        function connectToServer() {
            socket = new WebSocket('wss://codepath-mmorg.onrender.com');
            
            socket.onopen = function() {
                console.log('Connected to game server');
                
                // Send join game message with username and optional avatar
                const joinMessage = {
                    action: 'join_game',
                    username: gameState.username
                };
                
                // Add avatar if uploaded
                if (uploadedAvatar) {
                    joinMessage.avatar = uploadedAvatar;
                }
                
                socket.send(JSON.stringify(joinMessage));
            };
            
            socket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message:', data);
                    
                    // Check for error responses first
                    if (data.success === false) {
                        console.error(`Error in ${data.action}:`, data.error);
                        showErrorMessage(data.error);
                        return;
                    }
                    
                    switch (data.action) {
                        case 'join_game':
                            handleJoinGame(data);
                            break;
                        case 'player_joined':
                            handlePlayerJoined(data);
                            break;
                        case 'players_moved':
                            handlePlayersMoved(data);
                            break;
                        case 'player_left':
                            handlePlayerLeft(data);
                            break;
                        default:
                            console.log('Unknown action:', data.action);
                    }
                } catch (error) {
                    console.error('Error parsing message:', error);
                    showErrorMessage('Invalid message format received from server');
                }
            };
            
            socket.onclose = function() {
                console.log('Disconnected from game server');
                stopMovement(); // Stop movement when disconnected
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }
        
        // Keyboard event handlers
        function handleKeyDown(event) {
            // Prevent default behavior for arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                event.preventDefault();
            }
            
            let keyName = null;
            
            switch (event.code) {
                case 'ArrowUp':
                    keyName = 'up';
                    break;
                case 'ArrowDown':
                    keyName = 'down';
                    break;
                case 'ArrowLeft':
                    keyName = 'left';
                    break;
                case 'ArrowRight':
                    keyName = 'right';
                    break;
            }
            
            // Set key state and start movement if not already moving
            if (keyName && !keyState[keyName]) {
                keyState[keyName] = true;
                // Clear click-to-move target when using keyboard
                targetPosition = null;
                isMovingToTarget = false;
                startMovement();
            }
        }
        
        function handleKeyUp(event) {
            let keyName = null;
            
            switch (event.code) {
                case 'ArrowUp':
                    keyName = 'up';
                    break;
                case 'ArrowDown':
                    keyName = 'down';
                    break;
                case 'ArrowLeft':
                    keyName = 'left';
                    break;
                case 'ArrowRight':
                    keyName = 'right';
                    break;
            }
            
            // Clear key state when key is released
            if (keyName && keyState[keyName]) {
                keyState[keyName] = false;
                // Movement will automatically stop if no keys are pressed
            }
        }
        
        // Show error message to user
        function showErrorMessage(message) {
            // Create a temporary error display
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(244, 67, 54, 0.9);
                color: white;
                padding: 20px;
                border-radius: 8px;
                font-family: Arial, sans-serif;
                font-size: 16px;
                z-index: 1000;
                max-width: 400px;
                text-align: center;
            `;
            
            document.body.appendChild(errorDiv);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }
        
        // Avatar upload state
        let uploadedAvatar = null;
        
        // Handle username dialog
        function showUsernameDialog() {
            const dialog = document.getElementById('usernameDialog');
            const usernameInput = document.getElementById('usernameInput');
            const joinButton = document.getElementById('joinButton');
            const avatarUpload = document.getElementById('avatarUpload');
            const avatarPreview = document.getElementById('avatarPreview');
            
            dialog.style.display = 'flex';
            usernameInput.focus();
            
            // Handle avatar upload
            avatarUpload.onchange = function(event) {
                const files = Array.from(event.target.files);
                if (files.length > 0) {
                    processAvatarUpload(files, avatarPreview);
                }
            };
            
            // Handle join button click
            joinButton.onclick = function() {
                const username = usernameInput.value.trim();
                if (username.length > 0) {
                    gameState.username = username;
                    dialog.style.display = 'none';
                    connectToServer();
                } else {
                    alert('Please enter a username');
                }
            };
            
            // Handle Enter key
            usernameInput.onkeypress = function(event) {
                if (event.key === 'Enter') {
                    joinButton.click();
                }
            };
        }
        
        // Process uploaded avatar images
        function processAvatarUpload(files, previewContainer) {
            if (files.length < 3) {
                alert('Please upload at least 3 images for avatar animation');
                return;
            }
            
            // Clear previous preview
            previewContainer.innerHTML = '';
            
            // Process files and create base64 data
            const processedFiles = [];
            let processedCount = 0;
            
            files.forEach((file, index) => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        processedFiles[index] = e.target.result;
                        processedCount++;
                        
                        // Create preview
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.style.cssText = 'width: 40px; height: 40px; margin: 2px; border: 1px solid #555;';
                        previewContainer.appendChild(img);
                        
                        // When all files are processed, create avatar object
                        if (processedCount === files.length) {
                            createAvatarObject(processedFiles);
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        
        // Create avatar object from processed images
        function createAvatarObject(imageData) {
            // For simplicity, we'll use the same frames for all directions
            // In a real implementation, you'd want to organize them by direction
            uploadedAvatar = {
                name: 'custom_avatar',
                frames: {
                    north: imageData.slice(0, 3), // First 3 images for north
                    south: imageData.slice(0, 3), // Same for south (you could organize differently)
                    east: imageData.slice(0, 3)   // Same for east
                }
            };
            
            console.log('Avatar processed:', uploadedAvatar);
        }
        
        // Initialize the game
        async function initGame() {
            await loadWorldMap();
            resizeCanvas();
            showUsernameDialog();
            
            // Add keyboard event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Add click event listener for click-to-move
            canvas.addEventListener('click', handleCanvasClick);
        }
        
        // Cleanup function
        function cleanup() {
            stopMovement();
            if (socket) {
                socket.close();
            }
        }
        
        // Event listeners
        window.addEventListener('load', initGame);
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
